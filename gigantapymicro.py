# -*- coding: utf-8 -*-
"""gigantapymicro.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YQCUOztWe-w0RlOrOhPKM7RSICxN8Fsy
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import random
import pvlib
from scipy.signal import savgol_filter
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_absolute_error
from sklearn.model_selection import TimeSeriesSplit

np.random.seed(42)
random.seed(42)

LAT = -3.730460361768245
LON = -38.67256024083137
TZ = "America/Fortaleza"

def clean_power_value(x):
    if pd.isna(x):
        return np.nan
    s = str(x).strip().replace(".", "").replace(",", ".")
    try:
        val = float(s)
    except:
        return np.nan
    while val > 1800:
        val /= 10
    return round(val, 3)

def remove_spikes(df, window=9, mad_multiplier=6):
    df = df.copy()
    power = df["power"].to_numpy(dtype=float)
    if len(power) < window:
        return df
    med = pd.Series(power).rolling(window=window, center=True).median().bfill().ffill().to_numpy()
    resid = power - med
    mad = np.median(np.abs(resid))
    if mad == 0:
        mad = np.std(resid) if np.std(resid) > 0 else 1.0
    spike_mask = np.abs(resid) > (mad_multiplier * mad)
    cleaned = power.copy()
    idxs = np.where(spike_mask)[0]
    for i in idxs:
        left = max(0, i - window // 2)
        right = min(len(power), i + window // 2 + 1)
        cleaned[i] = np.median(power[left:right][~np.isnan(power[left:right])]) if np.any(~np.isnan(power[left:right])) else med[i]
    df["power"] = cleaned
    return df

def smooth_power(df, window=7):
    df = df.copy()
    s = df["power"].rolling(window=window, center=True).median()
    df["power"] = s.bfill().ffill()
    return df

def load_dataset(path, col_power_name, inversor_label):
    df = pd.read_csv(path)
    df = df.rename(columns={
        "Timestamp": "timestamp",
        "Entity Name": "inversor",
        col_power_name: "power"
    })
    df = df[df["inversor"] == inversor_label].copy()
    df["power"] = df["power"].apply(clean_power_value)
    df = df.dropna(subset=["power"])
    df["timestamp"] = pd.to_datetime(df["timestamp"], errors="coerce")
    df = df.dropna(subset=["timestamp"])
    df = df.sort_values("timestamp").set_index("timestamp")
    full_range = pd.date_range(df.index.min(), df.index.max(), freq="10min")
    df = df.reindex(full_range)
    df.index.name = "timestamp"
    df["power"] = df["power"].interpolate(limit_area="inside")
    df = remove_spikes(df, window=9, mad_multiplier=6)
    df = smooth_power(df, window=7)
    df["power"] = df["power"].fillna(0.0)
    if df.index.tz is None:
        df.index = df.index.tz_localize(TZ)
    return df

def add_time_features(df):
    df = df.copy()
    idx = df.index.tz_convert(TZ) if getattr(df.index, "tz", None) is not None else df.index
    df["hour"] = idx.hour
    df["minute"] = idx.minute
    df["minute_of_day"] = idx.hour * 60 + idx.minute
    df["dayofyear"] = idx.dayofyear
    df["month"] = idx.month
    df["weekday"] = idx.weekday
    df["sin_min"] = np.sin(2 * np.pi * df["minute_of_day"] / (24*60))
    df["cos_min"] = np.cos(2 * np.pi * df["minute_of_day"] / (24*60))
    df["sin_doy"] = np.sin(2 * np.pi * df["dayofyear"] / 365.25)
    df["cos_doy"] = np.cos(2 * np.pi * df["dayofyear"] / 365.25)
    return df

def add_solar_features(df):
    df = df.copy()
    if df.index.tz is None:
        df.index = df.index.tz_localize(TZ)
    else:
        if str(df.index.tz) != TZ:
            df.index = df.index.tz_convert(TZ)
    loc = pvlib.location.Location(LAT, LON, tz=TZ)
    solpos = loc.get_solarposition(df.index)
    df["solar_zenith"] = solpos["zenith"]
    df["solar_elevation"] = solpos["elevation"]
    df["solar_elevation_pos"] = df["solar_elevation"].clip(lower=0)
    df["solar_azimuth"] = solpos["azimuth"]
    df["irr_theoretical"] = np.sin(np.radians(df["solar_elevation_pos"]))
    return df

def add_clearsky_features(df):
    df = df.copy()
    if df.index.tz is None:
        df.index = df.index.tz_localize(TZ)
    else:
        if str(df.index.tz) != TZ:
            df.index = df.index.tz_convert(TZ)
    loc = pvlib.location.Location(LAT, LON, tz=TZ)
    cs = loc.get_clearsky(df.index, model="ineichen")
    df["ghi_cs"] = cs["ghi"]
    df["dni_cs"] = cs["dni"]
    df["dhi_cs"] = cs["dhi"]
    return df

def build_climatology(df):
    dfc = add_time_features(df)
    climat = dfc.groupby("minute_of_day")["power"].median()
    climat = climat.reindex(range(0, 24*60)).interpolate().fillna(0.0)
    return climat

def estimate_daylight_range(climatology, power_frac_threshold=0.05):
    maxp = climatology.max()
    if maxp <= 0:
        return 6*60, 18*60
    thr = maxp * power_frac_threshold
    daylight_mask = climatology > thr
    idxs = np.where(daylight_mask)[0]
    if len(idxs) == 0:
        return 6*60, 18*60
    start = int(idxs.min())
    end = int(idxs.max())
    return start, end

def postprocess_pred_series(df_future, raw_pred, climatology, daylight_range, max_delta=35, climatology_factor=1.15):
    n = len(raw_pred)
    p = np.asarray(raw_pred).astype(float).copy()
    df2 = df_future.copy()
    if "solar_elevation_pos" not in df2.columns:
        df2 = add_solar_features(df2)
    if "ghi_cs" not in df2.columns:
        df2 = add_clearsky_features(df2)
    if "minute_of_day" not in df2.columns:
        df2 = add_time_features(df2)
    mins = df2["minute_of_day"].values
    climat_full = climatology.reindex(range(0,24*60)).fillna(0.0).values
    clim_limit = climat_full[mins] * climatology_factor
    p = np.minimum(p, clim_limit)
    final = np.zeros(n, dtype=float)
    df2["pred_tmp"] = p
    df2["date"] = df2.index.date
    groups = df2.groupby("date").indices
    for d, idx_positions in groups.items():
        idxs = np.array(idx_positions, dtype=int)
        seg_pred = df2["pred_tmp"].values[idxs]
        seg_elev = df2["solar_elevation_pos"].values[idxs]
        day_mask = seg_elev > 0
        seg_full = np.zeros_like(seg_pred)
        if day_mask.sum() > 0:
            first = np.where(day_mask)[0][0]
            last = np.where(day_mask)[0][-1]
            seg_day = seg_pred[first:last+1].copy()
            win = min(21, len(seg_day))
            if win % 2 == 0 and win > 1:
                win -= 1
            if win >= 5 and len(seg_day) >= win:
                try:
                    seg_day = savgol_filter(seg_day, win, 3)
                except Exception:
                    pass
            seg_day = np.clip(seg_day, 0.0, None)
            seg_full[first:last+1] = seg_day
        final[idxs] = seg_full
    final[df2["solar_elevation_pos"].values <= 0] = 0.0
    return final

def train_regression_model(df):
    df = df.copy()
    df = add_time_features(df)
    df = add_solar_features(df)
    df = add_clearsky_features(df)
    climat = build_climatology(df)
    day_start, day_end = estimate_daylight_range(climat, power_frac_threshold=0.05)
    df["climatology"] = df["minute_of_day"].map(climat)
    df = df.dropna()
    y = df["power"]
    X = df[[
        "hour", "minute", "minute_of_day", "dayofyear", "month", "weekday",
        "sin_min", "cos_min", "sin_doy", "cos_doy",
        "solar_zenith", "solar_elevation", "solar_azimuth",
        "irr_theoretical",
        "ghi_cs", "dni_cs", "dhi_cs",
        "climatology"
    ]]
    tscv = TimeSeriesSplit(n_splits=5)
    maes = []
    for train_idx, test_idx in tscv.split(X):
        X_train, X_test = X.iloc[train_idx], X.iloc[test_idx]
        y_train, y_test = y.iloc[train_idx], y.iloc[test_idx]
        model = RandomForestRegressor(n_estimators=800, max_depth=18, random_state=42, n_jobs=1)
        model.fit(X_train, y_train)
        pred = model.predict(X_test)
        maes.append(mean_absolute_error(y_test, pred))
    mae_final = float(np.mean(maes))
    print(f"MAE médio: {mae_final:.3f} W")
    final_model = RandomForestRegressor(n_estimators=800, max_depth=18, random_state=42, n_jobs=1)
    final_model.fit(X, y)
    return final_model, mae_final, climat, (day_start, day_end)

def forecast_next_days(model, climatology, daylight_range, start_date, days=7):
    start_time = pd.to_datetime(start_date).normalize()
    end_time = start_time + pd.Timedelta(days=days) - pd.Timedelta(minutes=10)
    future_range = pd.date_range(start=start_time, end=end_time, freq="10min", tz=TZ)
    df_future = pd.DataFrame(index=future_range)
    df_future = add_time_features(df_future)
    df_future = add_solar_features(df_future)
    df_future = add_clearsky_features(df_future)
    df_future["climatology"] = df_future["minute_of_day"].map(climatology).fillna(0.0)
    features = [
        "hour", "minute", "minute_of_day", "dayofyear", "month", "weekday",
        "sin_min", "cos_min", "sin_doy", "cos_doy",
        "solar_zenith", "solar_elevation", "solar_azimuth",
        "irr_theoretical",
        "ghi_cs", "dni_cs", "dhi_cs",
        "climatology"
    ]
    raw_pred = model.predict(df_future[features])
    final_pred = postprocess_pred_series(df_future, raw_pred, climatology, daylight_range)
    df_future["predicted_power"] = final_pred
    return df_future

def plot_real_vs_pred(df, model, climatology, daylight_range, title="Real vs Previsto"):
    df2 = df.copy()
    df2 = add_time_features(df2)
    df2 = add_solar_features(df2)
    df2 = add_clearsky_features(df2)
    df2["climatology"] = df2["minute_of_day"].map(climatology).fillna(0.0)
    features = [
        "hour", "minute", "minute_of_day", "dayofyear", "month", "weekday",
        "sin_min", "cos_min", "sin_doy", "cos_doy",
        "solar_zenith", "solar_elevation", "solar_azimuth",
        "irr_theoretical",
        "ghi_cs", "dni_cs", "dhi_cs",
        "climatology"
    ]
    raw_pred = model.predict(df2[features])
    pred_final = postprocess_pred_series(df2, raw_pred, climatology, daylight_range)
    df2["pred"] = pred_final
    plt.figure(figsize=(15,5))
    plt.plot(df2.index, df2["power"], label="Real", linewidth=1.2)
    plt.plot(df2.index, df2["pred"], label="Previsto", linewidth=1)
    plt.title(title, fontsize=15)
    plt.xlabel("Tempo")
    plt.ylabel("Potência (W)")
    plt.legend()
    plt.grid(True, alpha=0.4)
    plt.tight_layout()
    plt.show()

def run_training_and_forecast(clean_path, dirty_path):
    print("Carregando dataset LIMPO...")
    df_clean = load_dataset(clean_path, "IP - LIMPOS", "INVERSOR_1")
    print("Carregando dataset SUJO...")
    df_dirty = load_dataset(dirty_path, "IP 2 - SUJOS", "INVERSOR_2")
    inicio = "2025-10-29"
    fim = "2025-10-31"
    df_clean = df_clean[inicio:fim]
    df_dirty = df_dirty[inicio:fim]
    print("Treinando modelo LIMPO...")
    model_clean, mae_clean, climat_clean, daylight_clean = train_regression_model(df_clean)
    print("Treinando modelo SUJO...")
    model_dirty, mae_dirty, climat_dirty, daylight_dirty = train_regression_model(df_dirty)
    print("\nCOMPARAÇÃO DE MAE")
    print(f"MAE LIMPO: {mae_clean:.2f} W")
    print(f"MAE SUJO: {mae_dirty:.2f} W")
    forecast_clean = forecast_next_days(model_clean, climat_clean, daylight_clean, start_date="2025-11-01", days=1)
    forecast_dirty = forecast_next_days(model_dirty, climat_dirty, daylight_dirty, start_date="2025-11-01", days=1)
    print("\nReal vs Previsto (LIMPO)")
    plot_real_vs_pred(df_clean, model_clean, climat_clean, daylight_clean, "Real vs Previsto — LIMPO")
    print("Real vs Previsto (SUJO)")
    plot_real_vs_pred(df_dirty, model_dirty, climat_dirty, daylight_dirty, "Real vs Previsto — SUJO")
    return forecast_clean, forecast_dirty

if __name__ == "__main__":
    clean_csv = "limpo-potências_painéis_ AGOSTO-OUTUBRO.csv"
    dirty_csv = "sujo-potências_painéis_ AGOSTO-OUTUBRO.csv"
    f_clean, f_dirty = run_training_and_forecast(clean_csv, dirty_csv)
    print("\nPrimeiras linhas da previsão (LIMPO):")
    display(f_clean.head())
    print("\nPrimeiras linhas da previsão (SUJO):")
    display(f_dirty.head())